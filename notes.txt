
resources:
  . https://www.khronos.org/opengl/wiki/Compute_Shader
  . https://www.khronos.org/opengl/wiki/Sampler_(GLSL)
  . https://www.w3.org/TR/WGSL/
  . https://sotrh.github.io/learn-wgpu
  . https://gpuweb.github.io/gpuweb/wgsl/#builtin-functions

  . for wgpu on browser
    . https://github.com/sotrh/learn-wgpu/tree/master/code/showcase/pong
    . https://sotrh.github.io/learn-wgpu/showcase/pong/
    . look for wasm examples in wgpu

custom commands:
  . /// import ./shader_path
    . keep track of what files included and dont import files multiple times
  . /// compute_enable
  . /// work_group_count 64

fractal resources:
  . https://iquilezles.org/articles/
  . http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/

bugs:
  . 

plan:
  . maybe increase/decrease the cumpute_buffer invocations/iterations_per_frame based on the frame time
    . how do i check fps?
    . ig its already sync cuz get_current_texture() ??
      . is the winit eventloop async?
        . so can another iteration start before one ends?
  . sliders for variables
    . pressing some button + scrolling
  . how anti-aliasing
  . can i dump gifs

new ideas:
  . render a 3d fractal with z axis as the f(iteration count).
    . where f can be a scaling func like sqrt or log
  . so at z=0, its just a plane, but as it goes further away, it forms the fractal but clearer

flame fractals??
  . https://en.wikipedia.org/wiki/Fractal_flame
  . this tut looks good: https://fractalformulas.wordpress.com/2017/05/01/basics-of-flame-fractals/
  . https://www.ultrafractal.com/kb/flamefractals.html

buddhabrot:
  . since this implimentation can know about the exact iteration count of trajectory,
    have a color mode that colors based on the trajectory length
  . try complex to the power complex number equation
    . https://math.stackexchange.com/questions/476968/complex-power-of-a-complex-number
  . what happens with non polynomial functions?
    . cuz slight variations to complex number calculation still produces fractals
  . mandlebrot, but mirror the point so that it always stays in the first quadrant
    . or some other variations of this kind
  . get more julia buddhabrot things + the rooty stuff
  . optimisation techniques?: https://github.com/Michaelangel007/buddhabrot
  . orbit traps???
    . can this be applied in bbrot somehow?

buddhabrot but only a section:
  . https://benedikt-bitterli.me/buddhabrot/
  . https://github.com/Quuxplusone/Buddhabrot
  . execute for a grid, find all points that contribute to current section.
    then look for new points in finer grid around the good points (take care of overlap)
    and repeat n times while discarding bottom p percentage of points that no not contribute much points.
    . be careful not to just use points from very small regions. instead allow a range of "contributions"
      and discard anything outside it
  . finally select random points from the good regions
  . choosing not fine enough grid initially will cause to miss a lot of good zones

mandlebrot:
  . make the juliabrot viewer. kinda like in the 3b1b vid: https://youtu.be/LqbZpur38nw at 8:02
    . use 2 sets of triangles to cover half a screen each
      . just overlay the mandlebrot render quardilateral on top of the julia one.
    . spawn 2 windows and let user arrange them
  . newton's fractal
    . wip wgsl rust: https://github.com/agausmann/NewtonFractal
  . smooth coloring
    . histogram equalization technique
      .https://github.com/Smoltbob/fractals_rust/blob/master/src/main.rs
  . different coloring method for inside and outside fractals
    . inside points can use how close the point ends up to another fixed point or something
  . orbit traps!!!!!
    . https://iquilezles.org/articles/ftrapsgeometric/
    . https://en.wikipedia.org/wiki/Orbit_trap

plot:
  . 

notes:
  get wierd cool fractals: (works in both mbrot and bbrot)
    . needs non-smooth coloring
    k. equation (return k + c)
      1. k = v2f(z.x*z.x-z.y*z.y, 2.0*z.x*z.y);
      2. k = v2f(z.x*z.x+z.y*z.y, 2.0*z.x*z.y); // gives square
      3. k = v2f(z.x*z.x+z.y*z.y, -2.0*z.x*z.y); // gives bullet/droplet
    e. escape func 
      1. return z.x*z.x + z.y*z.y > 4.0;
      2. return 1.0/z.x + z.y*z.y > 4.0; // make wierd tendril things
      3. return 1.0/z.x - z.y*z.y > 4.0; // makes the background black
      4. return 0.2/z.x ......... > 4.0; // tendril things go smaller
    i. iteration
      1. min_iterations = 5000, max_iterations = 100000
      2. min_iterations = 0, max_iterations = 10
      3. min_iterations = 0, max_iterations = 20
      1. min_iterations = 5000, max_iterations = 100000
    
    o. observation:
      1. k1 + e1 + i1 -> normal bbrot
      2. e1 + i2
        . (does not give anything intresting in bbrot)
        1. k2 -> gives square in mandlebrot
        2. k3 -> gives droplet shaper in mandlebrot
      3. k* + i2
        . (i2 -> no glow around tendrils)
        1. e2 -> rooty/tendrils + bright background
        2. e3 -> rooty/tendrils + dark background
        3. e4 -> rooty/tendrils + thinner tendrils
      4. k* + i3 -> o3 + glow
      5. with anti bbrot:
        1. o3.2 and o3.3 swap behaviour
        2. prefer a bit higher iterations (a lil bit higher than i3)
        3. k2 and k3 have very unintresting results

